<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="3.2" jmeter="3.3 r1808647">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="Test Plan" enabled="true">
      <stringProp name="TestPlan.comments"></stringProp>
      <boolProp name="TestPlan.functional_mode">false</boolProp>
      <boolProp name="TestPlan.serialize_threadgroups">false</boolProp>
      <elementProp name="TestPlan.user_defined_variables" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
        <collectionProp name="Arguments.arguments"/>
      </elementProp>
      <stringProp name="TestPlan.user_define_classpath"></stringProp>
    </TestPlan>
    <hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">startnextloop</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">${__P(loops, 1)}</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">${__P(threads, 1)}</stringProp>
        <stringProp name="ThreadGroup.ramp_time">${__P(threads, 1)}</stringProp>
        <longProp name="ThreadGroup.start_time">1508372483000</longProp>
        <longProp name="ThreadGroup.end_time">1508372483000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="Counter" enabled="true">
          <stringProp name="CounterConfig.start">1</stringProp>
          <stringProp name="CounterConfig.end"></stringProp>
          <stringProp name="CounterConfig.incr">1</stringProp>
          <stringProp name="CounterConfig.name">runNumber</stringProp>
          <stringProp name="CounterConfig.format"></stringProp>
          <boolProp name="CounterConfig.per_user">false</boolProp>
        </CounterConfig>
        <hashTree/>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
          <collectionProp name="Arguments.arguments">
            <elementProp name="batchCsvFile" elementType="Argument">
              <stringProp name="Argument.name">batchCsvFile</stringProp>
              <stringProp name="Argument.value">${__P(batchfile, fixtures/sample-batch.csv)}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="continueBatchLoop" elementType="Argument">
              <stringProp name="Argument.name">continueBatchLoop</stringProp>
              <stringProp name="Argument.value">true</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="feedUrl" elementType="Argument">
              <stringProp name="Argument.name">feedUrl</stringProp>
              <stringProp name="Argument.value">http://documents.atlantaregional.com/transitdata/gtfs_ASC.zip</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="processingFeedVersionJob" elementType="Argument">
              <stringProp name="Argument.name">processingFeedVersionJob</stringProp>
              <stringProp name="Argument.value">true</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="projectName" elementType="Argument">
              <stringProp name="Argument.name">projectName</stringProp>
              <stringProp name="Argument.value">${__P(project,test project)}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="testPlanMode" elementType="Argument">
              <stringProp name="Argument.name">testPlanMode</stringProp>
              <stringProp name="Argument.value">${__P(mode,upload)}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="uploadPath" elementType="Argument">
              <stringProp name="Argument.name">uploadPath</stringProp>
              <stringProp name="Argument.value">fixtures/gtfs.zip</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <ConfigTestElement guiclass="HttpDefaultsGui" testclass="ConfigTestElement" testname="HTTP Request Defaults" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
            <collectionProp name="Arguments.arguments"/>
          </elementProp>
          <stringProp name="HTTPSampler.domain">localhost</stringProp>
          <stringProp name="HTTPSampler.port">4000</stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="TestPlan.comments">Assumes that datatools-server is running on port 4000</stringProp>
          <stringProp name="HTTPSampler.concurrentPool">6</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
        </ConfigTestElement>
        <hashTree/>
        <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
          <collectionProp name="HeaderManager.headers">
            <elementProp name="" elementType="Header">
              <stringProp name="Header.name">Accept-Encoding</stringProp>
              <stringProp name="Header.value">gzip</stringProp>
            </elementProp>
          </collectionProp>
        </HeaderManager>
        <hashTree/>
        <WhileController guiclass="WhileControllerGui" testclass="WhileController" testname="While Controller - Continue with next batch record?" enabled="true">
          <stringProp name="WhileController.condition">${continueBatchLoop}</stringProp>
          <stringProp name="TestPlan.comments">Used to determine if this loop should be completed again by advancing to the next record in a batch csv file</stringProp>
        </WhileController>
        <hashTree>
          <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="Counter" enabled="true">
            <stringProp name="CounterConfig.start">1</stringProp>
            <stringProp name="CounterConfig.end"></stringProp>
            <stringProp name="CounterConfig.incr">1</stringProp>
            <stringProp name="CounterConfig.name">batchFeedIdx</stringProp>
            <stringProp name="CounterConfig.format"></stringProp>
            <boolProp name="CounterConfig.per_user">true</boolProp>
            <boolProp name="CounterConfig.reset_on_tg_iteration">true</boolProp>
          </CounterConfig>
          <hashTree/>
          <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller - upload or fetch feed test plan" enabled="true">
            <stringProp name="IfController.condition">&quot;${testPlanMode}&quot;==&quot;batch&quot; || &quot;${testPlanMode}&quot;==&quot;fetch&quot; || &quot;${testPlanMode}&quot;==&quot;upload&quot;</stringProp>
            <boolProp name="IfController.evaluateAll">false</boolProp>
          </IfController>
          <hashTree>
            <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler" enabled="true">
              <stringProp name="cacheKey"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">/*
 * This is sort of a pre-everything processing thing.  It needs to be under this sampler because otherwise it applies to all samplers.
 */
 
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVRecord;

import java.io.*;
import java.util.*;

/** 
 * ----------------------------------------------------------------------------------------------------
 * create directory for output results if needed 
 * ----------------------------------------------------------------------------------------------------
 */
try {

	// returns pathnames for files and directory
	File f = new File(&quot;output/result&quot;);
	
	// create
	boolean bool = f.mkdirs();
	
	// print
	if (f.mkdirs()) {
		System.out.println(&quot;Output directory created&quot;);	
	}

} catch(Exception e) {

	// if any error occurs
	e.printStackTrace();
}

// if file already exists, don&apos;t overwrite it
File f = new File(&quot;output/result/feed-processing-job-times.csv&quot;);
if (!f.exists()) {
	// write new file with headers
	FileOutputStream out = new FileOutputStream(&quot;output/result/feed-processing-job-times.csv&quot;);
	String headers = &quot;timeStamp,elapsed,label,threadName,success,failureMessage&quot;;
	out.write(headers.getBytes(&quot;UTF-8&quot;));
	out.write(System.getProperty(&quot;line.separator&quot;).getBytes(&quot;UTF-8&quot;));
	out.flush();
	out.close();
}

/** 
 * ----------------------------------------------------------------------------------------------------
 * set variables for each thread loop, cause jmeter doesn&apos;t update it???
 * ----------------------------------------------------------------------------------------------------
 */
vars.put(&quot;processingFeedVersionJob&quot;, &quot;true&quot;);

/** 
 * ----------------------------------------------------------------------------------------------------
 * read csv file for batch processing if needed
 * ----------------------------------------------------------------------------------------------------
 */
if (vars.get(&quot;testPlanMode&quot;).equals(&quot;batch&quot;)) {
	int feedIdx = Integer.parseInt(vars.get(&quot;batchFeedIdx&quot;));
	
	 // read csv file
	Reader rdr = null;
	try {
		  rdr = new FileReader(vars.get(&quot;batchCsvFile&quot;));
		  Iterable&lt;CSVRecord&gt; records = CSVFormat.RFC4180.withFirstRecordAsHeader().parse(rdr);
		  int curRowIdx = 0;
		  Iterator&lt;CSVRecord&gt; recordIterator = records.iterator();
		  while (recordIterator.hasNext() || curRowIdx &lt; feedIdx) {
		      curRowIdx++;
	     	 CSVRecord record = recordIterator.next();
	
		      // extract data from need row
		      if (curRowIdx == feedIdx) {
	     	     vars.put(&quot;projectName&quot;, record.get(&quot;project name&quot;));
		          String testPlanMode = record.get(&quot;fetch or upload&quot;);
		          vars.put(&quot;feedVersionCreationMode&quot;, testPlanMode);
	          	if (testPlanMode.equals(&quot;upload&quot;)) {
	     	         vars.put(&quot;uploadPath&quot;, record.get(&quot;file or http address&quot;));
		          } else {
		              vars.put(&quot;feedUrl&quot;, record.get(&quot;file or http address&quot;));
	          	}

	          	// check if loop should be exited
		      	if (!recordIterator.hasNext()) {
	          		vars.put(&quot;continueBatchLoop&quot;, &quot;false&quot;);
	      		}
	      		// data has been found, exit loop
	      		break;
	     	 }
	
		      // check if loop should be exited
		      if (!recordIterator.hasNext()) {
	          	vars.put(&quot;continueBatchLoop&quot;, &quot;false&quot;);
	      	}
	  	}
	} catch (Exception e) {
	  	e.printStackTrace();
	}
} else {
	// not in batch mode, set needed vars
	vars.put(&quot;feedVersionCreationMode&quot;, vars.get(&quot;testPlanMode&quot;));
	vars.put(&quot;continueBatchLoop&quot;, &quot;false&quot;);
}
</stringProp>
              <stringProp name="scriptLanguage">groovy</stringProp>
            </JSR223Sampler>
            <hashTree/>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="HTTP Request - Create Project" enabled="true">
              <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                <collectionProp name="Arguments.arguments">
                  <elementProp name="" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">false</boolProp>
                    <stringProp name="Argument.value">{&#xd;
  &quot;name&quot;: &quot;${projectName} ${runNumber}&quot;&#xd;
}</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                  </elementProp>
                </collectionProp>
              </elementProp>
              <stringProp name="HTTPSampler.domain"></stringProp>
              <stringProp name="HTTPSampler.port"></stringProp>
              <stringProp name="HTTPSampler.protocol"></stringProp>
              <stringProp name="HTTPSampler.contentEncoding"></stringProp>
              <stringProp name="HTTPSampler.path">/api/manager/secure/project</stringProp>
              <stringProp name="HTTPSampler.method">POST</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
              <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
              <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              <stringProp name="HTTPSampler.connect_timeout"></stringProp>
              <stringProp name="HTTPSampler.response_timeout"></stringProp>
            </HTTPSamplerProxy>
            <hashTree>
              <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Extractor - get projectId" enabled="true">
                <stringProp name="JSONPostProcessor.referenceNames">projectId</stringProp>
                <stringProp name="JSONPostProcessor.jsonPathExprs">$.id</stringProp>
                <stringProp name="JSONPostProcessor.match_numbers"></stringProp>
              </JSONPostProcessor>
              <hashTree/>
              <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                <collectionProp name="HeaderManager.headers">
                  <elementProp name="" elementType="Header">
                    <stringProp name="Header.name">Content-Type</stringProp>
                    <stringProp name="Header.value">application/json</stringProp>
                  </elementProp>
                </collectionProp>
              </HeaderManager>
              <hashTree/>
            </hashTree>
            <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller - upload test plan" enabled="true">
              <stringProp name="IfController.condition">&quot;${feedVersionCreationMode}&quot;==&quot;upload&quot;</stringProp>
              <boolProp name="IfController.evaluateAll">false</boolProp>
            </IfController>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="HTTP Request - Create Feedsource" enabled="true">
                <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">false</boolProp>
                      <stringProp name="Argument.value">{&#xd;
  &quot;name&quot;: &quot;test-feedsource&quot;, &#xd;
  &quot;projectId&quot;: &quot;${projectId}&quot;&#xd;
}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain"></stringProp>
                <stringProp name="HTTPSampler.port"></stringProp>
                <stringProp name="HTTPSampler.protocol"></stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/manager/secure/feedsource</stringProp>
                <stringProp name="HTTPSampler.method">POST</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <UniformRandomTimer guiclass="UniformRandomTimerGui" testclass="UniformRandomTimer" testname="Uniform Random Timer - 2-3s" enabled="true">
                  <stringProp name="ConstantTimer.delay">2000</stringProp>
                  <stringProp name="RandomTimer.range">1000.0</stringProp>
                </UniformRandomTimer>
                <hashTree/>
                <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Extractor - get feedSourceId" enabled="true">
                  <stringProp name="JSONPostProcessor.referenceNames">feedSourceId</stringProp>
                  <stringProp name="JSONPostProcessor.jsonPathExprs">$.id</stringProp>
                  <stringProp name="JSONPostProcessor.match_numbers"></stringProp>
                </JSONPostProcessor>
                <hashTree/>
                <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                  <collectionProp name="HeaderManager.headers">
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">Content-Type</stringProp>
                      <stringProp name="Header.value">application/json</stringProp>
                    </elementProp>
                  </collectionProp>
                </HeaderManager>
                <hashTree/>
              </hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="HTTP Request - Create Feed Version (by uploading zip)" enabled="true">
                <elementProp name="HTTPsampler.Files" elementType="HTTPFileArgs">
                  <collectionProp name="HTTPFileArgs.files">
                    <elementProp name="${uploadPath}" elementType="HTTPFileArg">
                      <stringProp name="File.path">${uploadPath}</stringProp>
                      <stringProp name="File.paramname"></stringProp>
                      <stringProp name="File.mimetype"></stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments"/>
                </elementProp>
                <stringProp name="HTTPSampler.domain"></stringProp>
                <stringProp name="HTTPSampler.port"></stringProp>
                <stringProp name="HTTPSampler.protocol"></stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/manager/secure/feedversion?feedSourceId=${feedSourceId}&amp;lastModified=1508291519372</stringProp>
                <stringProp name="HTTPSampler.method">POST</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                  <collectionProp name="HeaderManager.headers">
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">Content-Type</stringProp>
                      <stringProp name="Header.value">application/zip</stringProp>
                    </elementProp>
                  </collectionProp>
                </HeaderManager>
                <hashTree/>
                <UniformRandomTimer guiclass="UniformRandomTimerGui" testclass="UniformRandomTimer" testname="Uniform Random Timer - 2-3s" enabled="true">
                  <stringProp name="ConstantTimer.delay">2000</stringProp>
                  <stringProp name="RandomTimer.range">1000.0</stringProp>
                </UniformRandomTimer>
                <hashTree/>
                <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
                  <stringProp name="TestPlan.comments">Store time that upload completed</stringProp>
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">// get time that upload completed
long feedUploadCompleteTime = prev.getEndTime();

// store time to variable
vars.put(&quot;feedUploadCompleteTime&quot;, String.valueOf(feedUploadCompleteTime));</stringProp>
                </BeanShellPostProcessor>
                <hashTree/>
                <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Extractor" enabled="true">
                  <stringProp name="JSONPostProcessor.referenceNames">jobId</stringProp>
                  <stringProp name="JSONPostProcessor.jsonPathExprs">$.jobId</stringProp>
                  <stringProp name="JSONPostProcessor.match_numbers"></stringProp>
                </JSONPostProcessor>
                <hashTree/>
              </hashTree>
            </hashTree>
            <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller - fetch test plan" enabled="true">
              <stringProp name="IfController.condition">&quot;${feedVersionCreationMode}&quot;==&quot;fetch&quot;</stringProp>
              <boolProp name="IfController.evaluateAll">false</boolProp>
            </IfController>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="HTTP Request - Create Feedsource" enabled="true">
                <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">false</boolProp>
                      <stringProp name="Argument.value">{&#xd;
  &quot;name&quot;: &quot;test-feedsource&quot;, &#xd;
  &quot;projectId&quot;: &quot;${projectId}&quot;,&#xd;
  &quot;url&quot;: &quot;${feedUrl}&quot;&#xd;
}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain"></stringProp>
                <stringProp name="HTTPSampler.port"></stringProp>
                <stringProp name="HTTPSampler.protocol"></stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/manager/secure/feedsource</stringProp>
                <stringProp name="HTTPSampler.method">POST</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <UniformRandomTimer guiclass="UniformRandomTimerGui" testclass="UniformRandomTimer" testname="Uniform Random Timer - 2-3s" enabled="true">
                  <stringProp name="ConstantTimer.delay">2000</stringProp>
                  <stringProp name="RandomTimer.range">1000.0</stringProp>
                </UniformRandomTimer>
                <hashTree/>
                <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Extractor - get feedSourceId" enabled="true">
                  <stringProp name="JSONPostProcessor.referenceNames">feedSourceId</stringProp>
                  <stringProp name="JSONPostProcessor.jsonPathExprs">$.id</stringProp>
                  <stringProp name="JSONPostProcessor.match_numbers"></stringProp>
                </JSONPostProcessor>
                <hashTree/>
                <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                  <collectionProp name="HeaderManager.headers">
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">Content-Type</stringProp>
                      <stringProp name="Header.value">application/json</stringProp>
                    </elementProp>
                  </collectionProp>
                </HeaderManager>
                <hashTree/>
              </hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="HTTP Request - Create Feed Version (by fetching zip)" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments"/>
                </elementProp>
                <stringProp name="HTTPSampler.domain"></stringProp>
                <stringProp name="HTTPSampler.port"></stringProp>
                <stringProp name="HTTPSampler.protocol"></stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/manager/secure/feedsource/${feedSourceId}/fetch</stringProp>
                <stringProp name="HTTPSampler.method">POST</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                  <collectionProp name="HeaderManager.headers">
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">Content-Type</stringProp>
                      <stringProp name="Header.value">application/zip</stringProp>
                    </elementProp>
                  </collectionProp>
                </HeaderManager>
                <hashTree/>
                <UniformRandomTimer guiclass="UniformRandomTimerGui" testclass="UniformRandomTimer" testname="Uniform Random Timer - 2-3s" enabled="true">
                  <stringProp name="ConstantTimer.delay">2000</stringProp>
                  <stringProp name="RandomTimer.range">1000.0</stringProp>
                </UniformRandomTimer>
                <hashTree/>
                <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
                  <stringProp name="TestPlan.comments">Store time that upload completed</stringProp>
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">// get time that upload completed
long feedUploadCompleteTime = prev.getEndTime();

// store time to variable
vars.put(&quot;feedUploadCompleteTime&quot;, String.valueOf(feedUploadCompleteTime));</stringProp>
                </BeanShellPostProcessor>
                <hashTree/>
                <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Extractor" enabled="true">
                  <stringProp name="JSONPostProcessor.referenceNames">jobId</stringProp>
                  <stringProp name="JSONPostProcessor.jsonPathExprs">$.jobId</stringProp>
                  <stringProp name="JSONPostProcessor.match_numbers"></stringProp>
                </JSONPostProcessor>
                <hashTree/>
              </hashTree>
            </hashTree>
            <WhileController guiclass="WhileControllerGui" testclass="WhileController" testname="While Controller - wait for job to finish" enabled="true">
              <stringProp name="WhileController.condition">${processingFeedVersionJob}</stringProp>
            </WhileController>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="HTTP Request - job status" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments"/>
                </elementProp>
                <stringProp name="HTTPSampler.domain"></stringProp>
                <stringProp name="HTTPSampler.port"></stringProp>
                <stringProp name="HTTPSampler.protocol"></stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/manager/secure/status/jobs/${jobId}</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <ConstantTimer guiclass="ConstantTimerGui" testclass="ConstantTimer" testname="Constant Timer - 2s" enabled="true">
                  <stringProp name="ConstantTimer.delay">2000</stringProp>
                </ConstantTimer>
                <hashTree/>
                <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Extractor - check job completion status" enabled="true">
                  <stringProp name="JSONPostProcessor.referenceNames">feedSourceJobComplete;feedVersionId;feedSourceJobError;feedSourceJobMessage</stringProp>
                  <stringProp name="JSONPostProcessor.jsonPathExprs">$.status.completed;$.feedVersionId;$.status.error;$.status.message</stringProp>
                  <stringProp name="JSONPostProcessor.match_numbers"></stringProp>
                  <stringProp name="JSONPostProcessor.defaultValues">false;false;false;no message</stringProp>
                </JSONPostProcessor>
                <hashTree/>
                <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
                  <stringProp name="filename"></stringProp>
                  <stringProp name="parameters"></stringProp>
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="script">if (vars.get(&quot;feedSourceJobComplete&quot;) == &quot;true&quot;) {
	// save variable to exit loop
	vars.put(&quot;processingFeedVersionJob&quot;, &quot;false&quot;);
	
	// get time that job completed
	long jobCompleteTime = prev.getEndTime(); 
	
	// get HTTP Sampler 1 execution time from variable
	long feedUploadCompleteTime = Long.parseLong(vars.get(&quot;feedUploadCompleteTime&quot;)); 
	
	// calculate difference
	long feedProcessingTime = (jobCompleteTime - feedUploadCompleteTime);
	
	// open file for writing in append mode
	FileOutputStream out = new FileOutputStream(&quot;output/result/feed-processing-job-times.csv&quot;, true);
	
	// prepare row string
	// timeStamp
	String row = String.valueOf(jobCompleteTime) + &quot;,&quot;;
	
	// elapsed
	row += String.valueOf(feedProcessingTime) + &quot;,&quot;;
	
	// label
	row += &quot;Feed Processing Time,&quot;;
	
	// threadName
	row += &quot;Thread Group 1-&quot; + (ctx.getThreadNum() + 1) + &quot;,&quot;;
	
	// success and failureMessage
	String error = vars.get(&quot;feedSourceJobError&quot;);
	if (error.equals(&quot;true&quot;)) {
		String errorMessage = vars.get(&quot;feedSourceJobMessage&quot;);
		row += &quot;false,&quot; + errorMessage;
	} else {
		row += &quot;true,&quot;;
	}
	
	// write data
	out.write(row.getBytes(&quot;UTF-8&quot;));
	out.write(System.getProperty(&quot;line.separator&quot;).getBytes(&quot;UTF-8&quot;));
	out.flush();
	out.close();
}</stringProp>
                  <stringProp name="TestPlan.comments">Check if job is complete and if so, prepare to exit loop and calculate feed processing time</stringProp>
                </BeanShellPostProcessor>
                <hashTree/>
                <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion - Check that stop lengths are expected length" enabled="true">
                  <stringProp name="cacheKey"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="script">def failureMessage = &quot;&quot;;

// see if job is complete
if (vars.get(&quot;processingFeedVersionJob&quot;) == &quot;false&quot;) {
	if (vars.get(&quot;feedSourceJobError&quot;) == &quot;true&quot;) {
		failureMessage += &quot;an error occurred while processing the feed: &quot;
		failureMessage += vars.get(&quot;feedSourceJobMessage&quot;) + &quot;\n&quot;
	}
} else {
	// capture null response in event that job status returns null before it returns completion message
	if (prev.getResponseDataAsString().equals(&quot;null&quot;)) {
		failureMessage += &quot;received null job status response before job status completion was set to true\n&quot;
	}
}

// set assertion result to fail if an error happened
if (failureMessage?.trim()) {
	AssertionResult.setFailureMessage(failureMessage);
     AssertionResult.setFailure(true);    
}</stringProp>
                  <stringProp name="scriptLanguage">groovy</stringProp>
                </JSR223Assertion>
                <hashTree/>
              </hashTree>
            </hashTree>
          </hashTree>
          <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller - query projects test plan" enabled="true">
            <stringProp name="IfController.condition">&quot;${testPlanMode}&quot;==&quot;query&quot;</stringProp>
            <boolProp name="IfController.evaluateAll">false</boolProp>
          </IfController>
          <hashTree>
            <DebugSampler guiclass="TestBeanGUI" testclass="DebugSampler" testname="Debug Sampler - query" enabled="true">
              <boolProp name="displayJMeterProperties">false</boolProp>
              <boolProp name="displayJMeterVariables">true</boolProp>
              <boolProp name="displaySystemProperties">false</boolProp>
            </DebugSampler>
            <hashTree/>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="HTTP Request - Get projects" enabled="true">
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                <collectionProp name="Arguments.arguments"/>
              </elementProp>
              <stringProp name="HTTPSampler.domain"></stringProp>
              <stringProp name="HTTPSampler.port"></stringProp>
              <stringProp name="HTTPSampler.protocol"></stringProp>
              <stringProp name="HTTPSampler.contentEncoding"></stringProp>
              <stringProp name="HTTPSampler.path">/api/manager/secure/project</stringProp>
              <stringProp name="HTTPSampler.method">GET</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
              <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
              <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              <stringProp name="HTTPSampler.connect_timeout"></stringProp>
              <stringProp name="HTTPSampler.response_timeout"></stringProp>
            </HTTPSamplerProxy>
            <hashTree>
              <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="BeanShell PreProcessor - disable batch looping" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">// do not do batch loop in this case
vars.put(&quot;continueBatchLoop&quot;, &quot;false&quot;)</stringProp>
                <stringProp name="TestPlan.comments">Batch mode is not enabled in query mode</stringProp>
              </BeanShellPreProcessor>
              <hashTree/>
              <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Extractor - get a random project Id" enabled="true">
                <stringProp name="JSONPostProcessor.referenceNames">projectId</stringProp>
                <stringProp name="JSONPostProcessor.jsonPathExprs">$[*].id</stringProp>
                <stringProp name="JSONPostProcessor.match_numbers">0</stringProp>
              </JSONPostProcessor>
              <hashTree/>
              <JSR223PostProcessor guiclass="TestBeanGUI" testclass="JSR223PostProcessor" testname="JSR223 PostProcessor - Try to find the specified project if provided" enabled="true">
                <stringProp name="cacheKey"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="script">import groovy.json.JsonSlurper;

JsonSlurper JSON = new JsonSlurper ();

// if a custom project name is specified, try to find it.
// if a project matching the name is found, then override the projectId set by the JSON extractor in the step before this.
if (!vars.get(&quot;projectName&quot;).equals(&quot;test project&quot;)) {
	// parse json
	try {
		def jsonResponse = JSON.parseText(prev.getResponseDataAsString());
		jsonResponse.each{ project -&gt; 
			if (project.name.equals(vars.get(&quot;projectName&quot;))) {
				vars.put(&quot;projectId&quot;, project.id)
			}
		}
	} catch (Exception e) {
		
	}
}</stringProp>
                <stringProp name="scriptLanguage">groovy</stringProp>
              </JSR223PostProcessor>
              <hashTree/>
            </hashTree>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="HTTP Request - Get feed sources" enabled="true">
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                <collectionProp name="Arguments.arguments"/>
              </elementProp>
              <stringProp name="HTTPSampler.domain"></stringProp>
              <stringProp name="HTTPSampler.port"></stringProp>
              <stringProp name="HTTPSampler.protocol"></stringProp>
              <stringProp name="HTTPSampler.contentEncoding"></stringProp>
              <stringProp name="HTTPSampler.path">/api/manager/secure/feedsource?projectId=${projectId}</stringProp>
              <stringProp name="HTTPSampler.method">GET</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
              <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
              <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              <stringProp name="HTTPSampler.connect_timeout"></stringProp>
              <stringProp name="HTTPSampler.response_timeout"></stringProp>
            </HTTPSamplerProxy>
            <hashTree>
              <UniformRandomTimer guiclass="UniformRandomTimerGui" testclass="UniformRandomTimer" testname="Uniform Random Timer - 2-3s" enabled="true">
                <stringProp name="ConstantTimer.delay">2000</stringProp>
                <stringProp name="RandomTimer.range">1000.0</stringProp>
              </UniformRandomTimer>
              <hashTree/>
              <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Extractor" enabled="true">
                <stringProp name="JSONPostProcessor.referenceNames">feedSourceId</stringProp>
                <stringProp name="JSONPostProcessor.jsonPathExprs">$[*].id</stringProp>
                <stringProp name="JSONPostProcessor.match_numbers">0</stringProp>
              </JSONPostProcessor>
              <hashTree/>
            </hashTree>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="HTTP Request - Get feed versions" enabled="true">
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                <collectionProp name="Arguments.arguments"/>
              </elementProp>
              <stringProp name="HTTPSampler.domain"></stringProp>
              <stringProp name="HTTPSampler.port"></stringProp>
              <stringProp name="HTTPSampler.protocol"></stringProp>
              <stringProp name="HTTPSampler.contentEncoding"></stringProp>
              <stringProp name="HTTPSampler.path">/api/manager/secure/feedversion?feedSourceId=${feedSourceId}</stringProp>
              <stringProp name="HTTPSampler.method">GET</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
              <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
              <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              <stringProp name="HTTPSampler.connect_timeout"></stringProp>
              <stringProp name="HTTPSampler.response_timeout"></stringProp>
            </HTTPSamplerProxy>
            <hashTree>
              <UniformRandomTimer guiclass="UniformRandomTimerGui" testclass="UniformRandomTimer" testname="Uniform Random Timer - 2-3s" enabled="true">
                <stringProp name="ConstantTimer.delay">2000</stringProp>
                <stringProp name="RandomTimer.range">1000.0</stringProp>
              </UniformRandomTimer>
              <hashTree/>
              <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Extractor" enabled="true">
                <stringProp name="JSONPostProcessor.referenceNames">feedVersionId</stringProp>
                <stringProp name="JSONPostProcessor.jsonPathExprs">$[*].id</stringProp>
                <stringProp name="JSONPostProcessor.match_numbers">0</stringProp>
              </JSONPostProcessor>
              <hashTree/>
            </hashTree>
          </hashTree>
          <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Simple Controller - API Integrity" enabled="true"/>
          <hashTree>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="HTTP Request - Get Feed Version info" enabled="true">
              <elementProp name="HTTPsampler.Files" elementType="HTTPFileArgs">
                <collectionProp name="HTTPFileArgs.files">
                  <elementProp name="fixtures/gtfs_ASC.zip" elementType="HTTPFileArg">
                    <stringProp name="File.path">fixtures/gtfs_ASC.zip</stringProp>
                    <stringProp name="File.paramname">file</stringProp>
                    <stringProp name="File.mimetype">application/zip</stringProp>
                  </elementProp>
                </collectionProp>
              </elementProp>
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                <collectionProp name="Arguments.arguments"/>
              </elementProp>
              <stringProp name="HTTPSampler.domain"></stringProp>
              <stringProp name="HTTPSampler.port"></stringProp>
              <stringProp name="HTTPSampler.protocol"></stringProp>
              <stringProp name="HTTPSampler.contentEncoding"></stringProp>
              <stringProp name="HTTPSampler.path">/api/manager/secure/feedversion/${feedVersionId}</stringProp>
              <stringProp name="HTTPSampler.method">GET</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
              <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.DO_MULTIPART_POST">true</boolProp>
              <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              <stringProp name="HTTPSampler.connect_timeout"></stringProp>
              <stringProp name="HTTPSampler.response_timeout"></stringProp>
            </HTTPSamplerProxy>
            <hashTree>
              <UniformRandomTimer guiclass="UniformRandomTimerGui" testclass="UniformRandomTimer" testname="Uniform Random Timer - 2-3s" enabled="true">
                <stringProp name="ConstantTimer.delay">2000</stringProp>
                <stringProp name="RandomTimer.range">1000.0</stringProp>
              </UniformRandomTimer>
              <hashTree/>
              <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Extractor" enabled="true">
                <stringProp name="JSONPostProcessor.referenceNames">namespace</stringProp>
                <stringProp name="JSONPostProcessor.jsonPathExprs">$.namespace</stringProp>
                <stringProp name="JSONPostProcessor.match_numbers"></stringProp>
              </JSONPostProcessor>
              <hashTree/>
              <JSR223PostProcessor guiclass="TestBeanGUI" testclass="JSR223PostProcessor" testname="JSR223 PostProcessor - get service day with the most service hours" enabled="true">
                <stringProp name="scriptLanguage">groovy</stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="cacheKey"></stringProp>
                <stringProp name="script">import groovy.json.JsonSlurper;

def failureMessage = &quot;&quot;;
def jsonResponse = null;

JsonSlurper JSON = new JsonSlurper ();

// parse json
try {
	jsonResponse = JSON.parseText(prev.getResponseDataAsString());
} catch (Exception e) {
	failureMessage += &quot;Invalid JSON.\n&quot;
}

def curDate = jsonResponse.validationResult.firstCalendarDate.toInteger()
def dateWithMostService = curDate
def maxServiceSeconds = jsonResponse.validationResult.dailyTotalSeconds[0]

jsonResponse.validationResult.dailyTotalSeconds.each { 
	// Update maxServiceSeconds if needed
	if (it &gt; maxServiceSeconds) {
		dateWithMostService = curDate
		maxServiceSeconds = it
	}

	// increment cur date
	curDate += 1
}

vars.put(&quot;date&quot;, dateWithMostService.toString())</stringProp>
              </JSR223PostProcessor>
              <hashTree/>
            </hashTree>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="HTTP Request - Graphql - get stops" enabled="true">
              <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                <collectionProp name="Arguments.arguments">
                  <elementProp name="" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">false</boolProp>
                    <stringProp name="Argument.value">{&quot;query&quot;:&quot;\n      query stops($namespace: String) {\n        feed(namespace: $namespace) {\n          namespace\n          feed_id\n          feed_version\n          filename\n          row_counts {\n            stops\n          }\n          stops {\n            stop_id\n            stop_name\n            stop_lat\n            stop_lon\n          }\n        }\n      }\n    &quot;, &quot;variables&quot;: {&quot;namespace&quot;: &quot;${namespace}&quot; }}</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                  </elementProp>
                </collectionProp>
              </elementProp>
              <stringProp name="HTTPSampler.domain"></stringProp>
              <stringProp name="HTTPSampler.port"></stringProp>
              <stringProp name="HTTPSampler.protocol"></stringProp>
              <stringProp name="HTTPSampler.contentEncoding"></stringProp>
              <stringProp name="HTTPSampler.path">/api/manager/secure/gtfs/graphql</stringProp>
              <stringProp name="HTTPSampler.method">POST</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
              <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
              <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              <stringProp name="HTTPSampler.connect_timeout"></stringProp>
              <stringProp name="HTTPSampler.response_timeout"></stringProp>
            </HTTPSamplerProxy>
            <hashTree>
              <UniformRandomTimer guiclass="UniformRandomTimerGui" testclass="UniformRandomTimer" testname="Uniform Random Timer - 2-3s" enabled="true">
                <stringProp name="ConstantTimer.delay">2000</stringProp>
                <stringProp name="RandomTimer.range">1000.0</stringProp>
              </UniformRandomTimer>
              <hashTree/>
              <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                <collectionProp name="HeaderManager.headers">
                  <elementProp name="" elementType="Header">
                    <stringProp name="Header.name">Content-Type</stringProp>
                    <stringProp name="Header.value">application/json</stringProp>
                  </elementProp>
                </collectionProp>
              </HeaderManager>
              <hashTree/>
              <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion - Check that stop lengths are expected length" enabled="true">
                <stringProp name="cacheKey"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="script">import groovy.json.JsonSlurper;

def failureMessage = &quot;&quot;;
def jsonResponse = null;

JsonSlurper JSON = new JsonSlurper ();

// parse json
try {
	jsonResponse = JSON.parseText(prev.getResponseDataAsString());
} catch (Exception e) {
	failureMessage += &quot;Invalid JSON.\n&quot;
}

def totalNumStops = jsonResponse.data.feed.row_counts.stops
def lenQueriedStops = jsonResponse.data.feed.stops.size()

if (totalNumStops == 0) {
	failureMessage += &quot;recieved stop row count of 0 stops\n&quot;
}


if (lenQueriedStops == 0) {
	failureMessage += &quot;recieved 0 returned stops\n&quot;
}

if (lenQueriedStops &gt; 50) {
	failureMessage += &quot;recieved more than 50 returned stops\n&quot;
}

if (totalNumStops &lt; lenQueriedStops) {
	failureMessage += &quot;recieved more returned stops (&quot; + lenQueriedStops
	failureMessage += &quot;) than amount listed in row count of stops (&quot; + totalNumStops + &quot;)\n&quot;
}

// set assertion result to fail if an error happened
if (failureMessage?.trim()) {
	AssertionResult.setFailureMessage(failureMessage);
     AssertionResult.setFailure(true);    
}</stringProp>
                <stringProp name="scriptLanguage">groovy</stringProp>
              </JSR223Assertion>
              <hashTree/>
            </hashTree>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="HTTP Request - Graphql - get feed routes" enabled="true">
              <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                <collectionProp name="Arguments.arguments">
                  <elementProp name="" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">false</boolProp>
                    <stringProp name="Argument.value">{&quot;query&quot;:&quot;\n      query ($namespace: String) {\n        feed(namespace: $namespace) {\n          feed_id\n          feed_version\n          filename\n          routes {\n            route_id\n            route_type\n          }\n        }\n      }\n    &quot;, &quot;variables&quot;: {&quot;namespace&quot;: &quot;${namespace}&quot;}}</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                  </elementProp>
                </collectionProp>
              </elementProp>
              <stringProp name="HTTPSampler.domain"></stringProp>
              <stringProp name="HTTPSampler.port"></stringProp>
              <stringProp name="HTTPSampler.protocol"></stringProp>
              <stringProp name="HTTPSampler.contentEncoding"></stringProp>
              <stringProp name="HTTPSampler.path">/api/manager/secure/gtfs/graphql</stringProp>
              <stringProp name="HTTPSampler.method">POST</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
              <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
              <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              <stringProp name="HTTPSampler.connect_timeout"></stringProp>
              <stringProp name="HTTPSampler.response_timeout"></stringProp>
            </HTTPSamplerProxy>
            <hashTree>
              <UniformRandomTimer guiclass="UniformRandomTimerGui" testclass="UniformRandomTimer" testname="Uniform Random Timer - 1-2s" enabled="true">
                <stringProp name="ConstantTimer.delay">1000</stringProp>
                <stringProp name="RandomTimer.range">1000.0</stringProp>
              </UniformRandomTimer>
              <hashTree/>
              <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                <collectionProp name="HeaderManager.headers">
                  <elementProp name="" elementType="Header">
                    <stringProp name="Header.name">Content-Type</stringProp>
                    <stringProp name="Header.value">application/json</stringProp>
                  </elementProp>
                </collectionProp>
              </HeaderManager>
              <hashTree/>
              <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Extractor" enabled="true">
                <stringProp name="JSONPostProcessor.referenceNames">randomRouteId</stringProp>
                <stringProp name="JSONPostProcessor.jsonPathExprs">$.data.feed.routes[*].route_id</stringProp>
                <stringProp name="JSONPostProcessor.match_numbers">0</stringProp>
              </JSONPostProcessor>
              <hashTree/>
            </hashTree>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="HTTP Request - Graphql - get feed route trips" enabled="true">
              <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                <collectionProp name="Arguments.arguments">
                  <elementProp name="" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">false</boolProp>
                    <stringProp name="Argument.value">{&quot;query&quot;:&quot;\n      query ($namespace: String, $route_id: String) {\n        feed(namespace: $namespace) {\n          feed_id\n          feed_version\n          filename\n          routes (route_id: [$route_id]) {\n            route_id\n            route_type\n            trips {\n              trip_id\n              route_id\n            }\n          }\n        }\n      }\n    &quot;, &quot;variables&quot;: {&quot;namespace&quot;: &quot;${namespace}&quot;, &quot;route_id&quot;: &quot;${randomRouteId}&quot;}}</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                  </elementProp>
                </collectionProp>
              </elementProp>
              <stringProp name="HTTPSampler.domain"></stringProp>
              <stringProp name="HTTPSampler.port"></stringProp>
              <stringProp name="HTTPSampler.protocol"></stringProp>
              <stringProp name="HTTPSampler.contentEncoding"></stringProp>
              <stringProp name="HTTPSampler.path">/api/manager/secure/gtfs/graphql</stringProp>
              <stringProp name="HTTPSampler.method">POST</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
              <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
              <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              <stringProp name="HTTPSampler.connect_timeout"></stringProp>
              <stringProp name="HTTPSampler.response_timeout"></stringProp>
            </HTTPSamplerProxy>
            <hashTree>
              <UniformRandomTimer guiclass="UniformRandomTimerGui" testclass="UniformRandomTimer" testname="Uniform Random Timer - 1-2s" enabled="true">
                <stringProp name="ConstantTimer.delay">1000</stringProp>
                <stringProp name="RandomTimer.range">1000.0</stringProp>
              </UniformRandomTimer>
              <hashTree/>
              <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                <collectionProp name="HeaderManager.headers">
                  <elementProp name="" elementType="Header">
                    <stringProp name="Header.name">Content-Type</stringProp>
                    <stringProp name="Header.value">application/json</stringProp>
                  </elementProp>
                </collectionProp>
              </HeaderManager>
              <hashTree/>
              <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion - Check that all trips have same route_id as route" enabled="true">
                <stringProp name="cacheKey"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="script">import groovy.json.JsonSlurper;

def failureMessage = &quot;&quot;;
def jsonResponse = null;

JsonSlurper JSON = new JsonSlurper ();

// parse json
try {
	jsonResponse = JSON.parseText(prev.getResponseDataAsString());
} catch (Exception e) {
	failureMessage += &quot;Invalid JSON.\n&quot;
}

def trips = jsonResponse.data.feed.routes[0].trips

trips.each {
	if (!it.route_id.equals(vars.get(&quot;randomRouteId&quot;))) {
		failureMessage += &quot;route_id mismatch on trip: &quot; + it.trip_id + &quot;\n&quot;
	}
}

// set assertion result to fail if an error happened
if (failureMessage?.trim()) {
	AssertionResult.setFailureMessage(failureMessage);
     AssertionResult.setFailure(true);    
}</stringProp>
                <stringProp name="scriptLanguage">groovy</stringProp>
              </JSR223Assertion>
              <hashTree/>
            </hashTree>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="HTTP Request - Graphql - get feed route pattern trips" enabled="true">
              <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                <collectionProp name="Arguments.arguments">
                  <elementProp name="" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">false</boolProp>
                    <stringProp name="Argument.value">{&quot;query&quot;:&quot;\n      query ($namespace: String, $route_id: String) {\n        feed(namespace: $namespace) {\n          feed_id\n          feed_version\n          filename\n          routes (route_id: [$route_id]) {\n            route_id\n            route_type\n            patterns {\n              pattern_id\n              route_id\n              trips {\n                trip_id\n                pattern_id\n              }\n            }\n          }\n        }\n      }\n    &quot;, &quot;variables&quot;: {&quot;namespace&quot;: &quot;${namespace}&quot;, &quot;route_id&quot;: &quot;${randomRouteId}&quot;}}</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                  </elementProp>
                </collectionProp>
              </elementProp>
              <stringProp name="HTTPSampler.domain"></stringProp>
              <stringProp name="HTTPSampler.port"></stringProp>
              <stringProp name="HTTPSampler.protocol"></stringProp>
              <stringProp name="HTTPSampler.contentEncoding"></stringProp>
              <stringProp name="HTTPSampler.path">/api/manager/secure/gtfs/graphql</stringProp>
              <stringProp name="HTTPSampler.method">POST</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
              <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
              <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              <stringProp name="HTTPSampler.connect_timeout"></stringProp>
              <stringProp name="HTTPSampler.response_timeout"></stringProp>
            </HTTPSamplerProxy>
            <hashTree>
              <UniformRandomTimer guiclass="UniformRandomTimerGui" testclass="UniformRandomTimer" testname="Uniform Random Timer - 1-2s" enabled="true">
                <stringProp name="ConstantTimer.delay">1000</stringProp>
                <stringProp name="RandomTimer.range">1000.0</stringProp>
              </UniformRandomTimer>
              <hashTree/>
              <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                <collectionProp name="HeaderManager.headers">
                  <elementProp name="" elementType="Header">
                    <stringProp name="Header.name">Content-Type</stringProp>
                    <stringProp name="Header.value">application/json</stringProp>
                  </elementProp>
                </collectionProp>
              </HeaderManager>
              <hashTree/>
              <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion - Check that all patterns have same route_id" enabled="true">
                <stringProp name="cacheKey"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="script">import groovy.json.JsonSlurper;

def failureMessage = &quot;&quot;;
def jsonResponse = null;

JsonSlurper JSON = new JsonSlurper ();

// parse json
try {
	jsonResponse = JSON.parseText(prev.getResponseDataAsString());
} catch (Exception e) {
	failureMessage += &quot;Invalid JSON.\n&quot;
}

def patterns = jsonResponse.data.feed.routes[0].patterns

patterns.each {
	if (!it.route_id.equals(vars.get(&quot;randomRouteId&quot;))) {
		failureMessage += &quot;route_id mismatch on trip: &quot; + it.trip_id + &quot;\n&quot;
	}
}

// set assertion result to fail if an error happened
if (failureMessage?.trim()) {
	AssertionResult.setFailureMessage(failureMessage);
     AssertionResult.setFailure(true);    
}</stringProp>
                <stringProp name="scriptLanguage">groovy</stringProp>
              </JSR223Assertion>
              <hashTree/>
              <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Extractor" enabled="true">
                <stringProp name="JSONPostProcessor.referenceNames">randomPatternId</stringProp>
                <stringProp name="JSONPostProcessor.jsonPathExprs">$.data.feed.routes[0].patterns[*].pattern_id</stringProp>
                <stringProp name="JSONPostProcessor.match_numbers">0</stringProp>
              </JSONPostProcessor>
              <hashTree/>
            </hashTree>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="HTTP Request - Graphql - get feed route pattern stops and trips" enabled="true">
              <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                <collectionProp name="Arguments.arguments">
                  <elementProp name="" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">false</boolProp>
                    <stringProp name="Argument.value">{&quot;query&quot;:&quot;\n      query ($namespace: String, $pattern_id: String) {\n        feed(namespace: $namespace) {\n          feed_id\n          feed_version\n          filename\n          patterns (pattern_id: [$pattern_id]) {\n            pattern_id\n            route_id\n            stops {\n              stop_id\n            }\n            trips {\n              trip_id\n              pattern_id\n              stop_times {\n                stop_id\n                trip_id\n              }\n            }\n          }\n        }\n      }\n    &quot;, &quot;variables&quot;: {&quot;namespace&quot;: &quot;${namespace}&quot;, &quot;pattern_id&quot;: &quot;${randomPatternId}&quot;}}</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                  </elementProp>
                </collectionProp>
              </elementProp>
              <stringProp name="HTTPSampler.domain"></stringProp>
              <stringProp name="HTTPSampler.port"></stringProp>
              <stringProp name="HTTPSampler.protocol"></stringProp>
              <stringProp name="HTTPSampler.contentEncoding"></stringProp>
              <stringProp name="HTTPSampler.path">/api/manager/secure/gtfs/graphql</stringProp>
              <stringProp name="HTTPSampler.method">POST</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
              <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
              <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              <stringProp name="HTTPSampler.connect_timeout"></stringProp>
              <stringProp name="HTTPSampler.response_timeout"></stringProp>
            </HTTPSamplerProxy>
            <hashTree>
              <UniformRandomTimer guiclass="UniformRandomTimerGui" testclass="UniformRandomTimer" testname="Uniform Random Timer - 1-2s" enabled="true">
                <stringProp name="ConstantTimer.delay">1000</stringProp>
                <stringProp name="RandomTimer.range">1000.0</stringProp>
              </UniformRandomTimer>
              <hashTree/>
              <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                <collectionProp name="HeaderManager.headers">
                  <elementProp name="" elementType="Header">
                    <stringProp name="Header.name">Content-Type</stringProp>
                    <stringProp name="Header.value">application/json</stringProp>
                  </elementProp>
                </collectionProp>
              </HeaderManager>
              <hashTree/>
              <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion - Check that all stop_times have proper trip_id" enabled="true">
                <stringProp name="cacheKey"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="script">import groovy.json.JsonSlurper;

def failureMessage = &quot;&quot;;
def jsonResponse = null;

JsonSlurper JSON = new JsonSlurper ();

// parse json
try {
	jsonResponse = JSON.parseText(prev.getResponseDataAsString());
} catch (Exception e) {
	failureMessage += &quot;Invalid JSON.\n&quot;
}

def firstPattern = jsonResponse.data.feed.patterns[0]

if (firstPattern != null) {
	firstPattern.trips.each { trip -&gt;
		trip.stop_times.each { stop_time -&gt;
			if (!trip.trip_id.equals(stop_time.trip_id)) {
				failureMessage += &quot;trip_id mismatch.&quot;
				failureMessage += &quot;Parent trip has trip_id: &quot; + trip.trip_id
				failureMessage += &quot; Stop Time has stop_id: &quot; + stop_time.stop_id
				failureMessage += &quot; and trip_id: &quot; + stop_time.trip_id + &quot;\n&quot;
			}	
		}
	}
}

// set assertion result to fail if an error happened
if (failureMessage?.trim()) {
	AssertionResult.setFailureMessage(failureMessage);
     AssertionResult.setFailure(true);    
}</stringProp>
                <stringProp name="scriptLanguage">groovy</stringProp>
              </JSR223Assertion>
              <hashTree/>
              <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion - Check that all stop_times in trips on pattern have same stop sequence as pattern" enabled="true">
                <stringProp name="cacheKey"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="script">import groovy.json.JsonSlurper;

def failureMessage = &quot;&quot;;
def jsonResponse = null;

JsonSlurper JSON = new JsonSlurper ();

// parse json
try {
	jsonResponse = JSON.parseText(prev.getResponseDataAsString());
} catch (Exception e) {
	failureMessage += &quot;Invalid JSON.\n&quot;
}

def trips = jsonResponse.data.feed.patterns[0].trips

trips.each { trip -&gt;
	trip.stop_times.eachWithIndex { stop_time, idx -&gt;
		if (!stop_time.stop_id.equals(trip.stop_times[idx].stop_id)) {
			failureMessage += &quot;stop_id mismatch.&quot;
			failureMessage += &quot;Pattern stop list stop_id: &quot; + trip.stop_times[idx].stop_id
			failureMessage += &quot; at index: &quot; + idx
			failureMessage += &quot; Stop Time of trip &quot; + trip.trip_id 
			failureMessage += &quot; at index: &quot; + idx
			failureMessage += &quot; has stop_id: &quot; + stop_time.stop_id + &quot;\n&quot;
		}	
	}
}

// set assertion result to fail if an error happened
if (failureMessage?.trim()) {
	AssertionResult.setFailureMessage(failureMessage);
     AssertionResult.setFailure(true);    
}</stringProp>
                <stringProp name="scriptLanguage">groovy</stringProp>
              </JSR223Assertion>
              <hashTree/>
            </hashTree>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="HTTP Request - Graphql - get nested pattern stops." enabled="true">
              <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                <collectionProp name="Arguments.arguments">
                  <elementProp name="" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">false</boolProp>
                    <stringProp name="Argument.value">{&quot;query&quot;:&quot;query nestedQuery($namespace: String) {feed (namespace: $namespace) { routes(limit: 1) { patterns(limit: -1) { route { patterns(limit: -1) { route { route_id stops (limit: -1) { stop_id }}} route_id stops (limit: -1) { stop_id }}} route_id stops(limit: -1) { stop_id }}}}&quot;, &quot;variables&quot;: {&quot;namespace&quot;: &quot;${namespace}&quot;}}</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                  </elementProp>
                </collectionProp>
              </elementProp>
              <stringProp name="HTTPSampler.domain"></stringProp>
              <stringProp name="HTTPSampler.port"></stringProp>
              <stringProp name="HTTPSampler.protocol"></stringProp>
              <stringProp name="HTTPSampler.contentEncoding"></stringProp>
              <stringProp name="HTTPSampler.path">/api/manager/secure/gtfs/graphql</stringProp>
              <stringProp name="HTTPSampler.method">POST</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
              <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
              <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              <stringProp name="HTTPSampler.connect_timeout"></stringProp>
              <stringProp name="HTTPSampler.response_timeout"></stringProp>
              <stringProp name="TestPlan.comments">This should test whether the dataloader is able to cache queries and also if queries can be combined</stringProp>
            </HTTPSamplerProxy>
            <hashTree>
              <UniformRandomTimer guiclass="UniformRandomTimerGui" testclass="UniformRandomTimer" testname="Uniform Random Timer - 1-2s" enabled="true">
                <stringProp name="ConstantTimer.delay">1000</stringProp>
                <stringProp name="RandomTimer.range">1000.0</stringProp>
              </UniformRandomTimer>
              <hashTree/>
              <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                <collectionProp name="HeaderManager.headers">
                  <elementProp name="" elementType="Header">
                    <stringProp name="Header.name">Content-Type</stringProp>
                    <stringProp name="Header.value">application/json</stringProp>
                  </elementProp>
                </collectionProp>
              </HeaderManager>
              <hashTree/>
              <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion - Check that all feed-level routes have their route present in the routes of stops" enabled="true">
                <stringProp name="cacheKey"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="script">import groovy.json.JsonSlurper;

def failureMessage = &quot;&quot;;
def jsonResponse = null;

JsonSlurper JSON = new JsonSlurper ();

// parse json
try {
	jsonResponse = JSON.parseText(prev.getResponseDataAsString());
} catch (Exception e) {
	failureMessage += &quot;Invalid JSON.\n&quot;
}

def routes = jsonResponse.data.feed.routes

routes.each { route -&gt;
	routeId = route.route_id
	route.patterns.each { pattern -&gt;
		if (pattern.route[0].route_id != routeId) {
			failureMessage += &quot;route id not found in nested list of the route in a pattern.&quot;
			failureMessage += &quot;  Missing route id: &quot; + routeId + &quot;\n&quot;
		}
	}
}

// set assertion result to fail if an error happened
if (failureMessage?.trim()) {
	AssertionResult.setFailureMessage(failureMessage);
     AssertionResult.setFailure(true);    
}</stringProp>
                <stringProp name="scriptLanguage">groovy</stringProp>
              </JSR223Assertion>
              <hashTree/>
            </hashTree>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="HTTP Request - Graphql - get all shapes" enabled="true">
              <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                <collectionProp name="Arguments.arguments">
                  <elementProp name="" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">false</boolProp>
                    <stringProp name="Argument.value">{&quot;query&quot;:&quot;query shapesQuery($namespace: String) {feed (namespace: $namespace) {patterns(limit: -1) {shape(limit: -1) {shape_pt_lat shape_pt_lon shape_pt_sequence}}}}&quot;, &quot;variables&quot;: {&quot;namespace&quot;: &quot;${namespace}&quot;}}</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                  </elementProp>
                </collectionProp>
              </elementProp>
              <stringProp name="HTTPSampler.domain"></stringProp>
              <stringProp name="HTTPSampler.port"></stringProp>
              <stringProp name="HTTPSampler.protocol"></stringProp>
              <stringProp name="HTTPSampler.contentEncoding"></stringProp>
              <stringProp name="HTTPSampler.path">/api/manager/secure/gtfs/graphql</stringProp>
              <stringProp name="HTTPSampler.method">POST</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
              <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
              <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              <stringProp name="HTTPSampler.connect_timeout"></stringProp>
              <stringProp name="HTTPSampler.response_timeout"></stringProp>
              <stringProp name="TestPlan.comments">This tests a common query of getting all shapes of all patterns.</stringProp>
            </HTTPSamplerProxy>
            <hashTree>
              <UniformRandomTimer guiclass="UniformRandomTimerGui" testclass="UniformRandomTimer" testname="Uniform Random Timer - 1-2s" enabled="true">
                <stringProp name="ConstantTimer.delay">1000</stringProp>
                <stringProp name="RandomTimer.range">1000.0</stringProp>
              </UniformRandomTimer>
              <hashTree/>
              <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                <collectionProp name="HeaderManager.headers">
                  <elementProp name="" elementType="Header">
                    <stringProp name="Header.name">Content-Type</stringProp>
                    <stringProp name="Header.value">application/json</stringProp>
                  </elementProp>
                </collectionProp>
              </HeaderManager>
              <hashTree/>
            </hashTree>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="HTTP Request - Graphql - patternsQuery" enabled="true">
              <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                <collectionProp name="Arguments.arguments">
                  <elementProp name="" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">false</boolProp>
                    <stringProp name="Argument.value">{&quot;query&quot;:&quot;query patternsQuery($date: String, $namespace: String, $routeId: [String]) { feed (namespace: $namespace) { routes (route_id: $routeId) { route_id, route_short_name, route_long_name, patterns (limit: -1) { pattern_id, name, shape (limit: -1) { lat: shape_pt_lat lon: shape_pt_lon }, stops (limit: -1) { stop_id } trips ( date: $date, limit: -1 ) { stop_times (limit: 1) { arrival_time departure_time } } } stops (limit: -1) { location_type stop_code stop_desc stop_id stop_lat stop_lon stop_name stop_url wheelchair_boarding zone_id } } } }&quot;, &quot;variables&quot;: {&quot;date&quot;: &quot;${date}&quot;, &quot;namespace&quot;: &quot;${namespace}&quot;,  &quot;route_id&quot;: &quot;${randomRouteId}&quot;}}</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                  </elementProp>
                </collectionProp>
              </elementProp>
              <stringProp name="HTTPSampler.domain"></stringProp>
              <stringProp name="HTTPSampler.port"></stringProp>
              <stringProp name="HTTPSampler.protocol"></stringProp>
              <stringProp name="HTTPSampler.contentEncoding"></stringProp>
              <stringProp name="HTTPSampler.path">/api/manager/secure/gtfs/graphql</stringProp>
              <stringProp name="HTTPSampler.method">POST</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
              <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
              <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              <stringProp name="HTTPSampler.connect_timeout"></stringProp>
              <stringProp name="HTTPSampler.response_timeout"></stringProp>
              <stringProp name="TestPlan.comments">This executes the patternsQuery which is used to display the TripsPerHourChart in datatools-ui</stringProp>
            </HTTPSamplerProxy>
            <hashTree>
              <UniformRandomTimer guiclass="UniformRandomTimerGui" testclass="UniformRandomTimer" testname="Uniform Random Timer - 1-2s" enabled="true">
                <stringProp name="ConstantTimer.delay">1000</stringProp>
                <stringProp name="RandomTimer.range">1000.0</stringProp>
              </UniformRandomTimer>
              <hashTree/>
              <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                <collectionProp name="HeaderManager.headers">
                  <elementProp name="" elementType="Header">
                    <stringProp name="Header.name">Content-Type</stringProp>
                    <stringProp name="Header.value">application/json</stringProp>
                  </elementProp>
                </collectionProp>
              </HeaderManager>
              <hashTree/>
            </hashTree>
          </hashTree>
        </hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - reset continueBatchLoop variable" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey"></stringProp>
          <stringProp name="script">vars.put(&quot;continueBatchLoop&quot;, &quot;true&quot;)</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="TableVisualizer" testclass="ResultCollector" testname="View Results in Table" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>true</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
        <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>true</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>true</responseData>
              <samplerData>true</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>true</responseHeaders>
              <requestHeaders>true</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <fileName>true</fileName>
              <hostname>true</hostname>
              <threadCounts>true</threadCounts>
              <sampleCount>true</sampleCount>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
        <ResultCollector guiclass="SummaryReport" testclass="ResultCollector" testname="Summary Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
        <ResultCollector guiclass="RespTimeGraphVisualizer" testclass="ResultCollector" testname="Response Time Graph" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
        <ResultCollector guiclass="StatGraphVisualizer" testclass="ResultCollector" testname="Aggregate Graph" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
        <ResultCollector guiclass="GraphVisualizer" testclass="ResultCollector" testname="Graph Results" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>true</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>true</responseData>
              <samplerData>true</samplerData>
              <xml>true</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>true</responseHeaders>
              <requestHeaders>true</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <fileName>true</fileName>
              <hostname>true</hostname>
              <threadCounts>true</threadCounts>
              <sampleCount>true</sampleCount>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
    </hashTree>
    <WorkBench guiclass="WorkBenchGui" testclass="WorkBench" testname="WorkBench" enabled="true">
      <boolProp name="WorkBench.save">true</boolProp>
    </WorkBench>
    <hashTree>
      <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="true">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>true</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <sentBytes>true</sentBytes>
            <threadCounts>true</threadCounts>
            <idleTime>true</idleTime>
            <connectTime>true</connectTime>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
      </ResultCollector>
      <hashTree/>
      <ResultCollector guiclass="GraphVisualizer" testclass="ResultCollector" testname="Graph Results" enabled="true">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>true</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <sentBytes>true</sentBytes>
            <threadCounts>true</threadCounts>
            <idleTime>true</idleTime>
            <connectTime>true</connectTime>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
      </ResultCollector>
      <hashTree/>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
