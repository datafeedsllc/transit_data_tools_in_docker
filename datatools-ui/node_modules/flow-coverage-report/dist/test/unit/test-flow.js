'use strict';
'use babel';

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _minimatch = require('minimatch');

var _minimatch2 = _interopRequireDefault(_minimatch);

var _mockRequire = require('mock-require');

var _mockRequire2 = _interopRequireDefault(_mockRequire);

var _sinon = require('sinon');

var _sinon2 = _interopRequireDefault(_sinon);

var _ava = require('ava');

var _index = require('../../lib/index');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LIB_FLOW = '../../lib/flow';
var LIB_PROMISIFIED = '../../lib/promisified';
var NPM_TEMP = 'temp';

var tmpDirPath = '/tmp/fake-tmp-path';
var tmpFilePath = tmpDirPath + '/fake-tmp-file.json';

_ava.test.afterEach(function () {
  _mockRequire2.default.stopAll();
});

(0, _ava.test)('checkFlowStatus does not catch arbitrary errors', function () {
  var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(t) {
    var exec, writeFile, tempPath, flow;
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            exec = _sinon2.default.stub();
            writeFile = _sinon2.default.stub();
            tempPath = _sinon2.default.stub();


            (0, _mockRequire2.default)(NPM_TEMP, { path: tempPath });
            (0, _mockRequire2.default)(LIB_PROMISIFIED, { exec: exec, writeFile: writeFile });

            tempPath.onFirstCall().returns(tmpFilePath);
            exec.onFirstCall().returns(Promise.resolve({
              err: new Error('Fake flow status error')
            }));

            flow = _mockRequire2.default.reRequire(LIB_FLOW);


            t.is(tempPath.callCount, 0);

            _context.next = 11;
            return t.throws(flow.checkFlowStatus('flow', '/fake/projectDir/', tmpDirPath), 'Fake flow status error');

          case 11:

            t.true(exec.calledOnce);
            t.is(exec.firstCall.args[0], 'flow status --json');
            t.deepEqual(exec.firstCall.args[1], {
              cwd: '/fake/projectDir/',
              maxBuffer: Infinity
            });
            t.deepEqual(exec.firstCall.args[2], { dontReject: true });

            // No file should be created if the VERBOSE and
            // DEBUG_DUMP_JSON env var are not set
            t.is(tempPath.callCount, 0);
            t.is(writeFile.callCount, 0);

          case 17:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}());

(0, _ava.test)('checkFlowStatus resolves to flow types errors in json format', function () {
  var _ref2 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(t) {
    var exec, writeFile, tempPath, fakeJSONStatusReply, flow, res;
    return _regenerator2.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            exec = _sinon2.default.stub();
            writeFile = _sinon2.default.stub();
            tempPath = _sinon2.default.stub();


            (0, _mockRequire2.default)(NPM_TEMP, { path: tempPath });
            (0, _mockRequire2.default)(LIB_PROMISIFIED, { exec: exec, writeFile: writeFile });

            fakeJSONStatusReply = {
              passed: false,
              flowVersion: '0.30.0',
              errors: []
            };


            tempPath.onCall().returns(tmpFilePath);
            exec.onFirstCall().returns(Promise.resolve({
              err: { code: 2 },
              stdout: JSON.stringify(fakeJSONStatusReply)
            }));
            exec.onSecondCall().returns(Promise.resolve({ err: { code: 2 }, stdout: '' }));

            flow = _mockRequire2.default.reRequire(LIB_FLOW);
            _context2.next = 12;
            return flow.checkFlowStatus('flow', '/fake/projectDir/', tmpDirPath);

          case 12:
            res = _context2.sent;


            t.deepEqual(res, fakeJSONStatusReply);

            _context2.next = 16;
            return t.throws(flow.checkFlowStatus('flow', '/fake/projectDir/', tmpDirPath), /Parsing error on Flow status JSON result: SyntaxError: Unexpected end/);

          case 16:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));

  return function (_x2) {
    return _ref2.apply(this, arguments);
  };
}());

(0, _ava.test)('checkFlowStatus rejects on invalid flow status json format', function () {
  var _ref3 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3(t) {
    var exec, tempPath, fakeJSONStatusReply, flow;
    return _regenerator2.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            exec = _sinon2.default.stub();
            tempPath = _sinon2.default.stub();


            (0, _mockRequire2.default)(NPM_TEMP, { path: tempPath });
            (0, _mockRequire2.default)(LIB_PROMISIFIED, { exec: exec });

            fakeJSONStatusReply = {
              notFlowStatusJSON: true
            };


            exec.onFirstCall().returns(Promise.resolve({
              stdout: JSON.stringify(fakeJSONStatusReply)
            }));

            flow = _mockRequire2.default.reRequire(LIB_FLOW);
            _context3.next = 9;
            return t.throws(flow.checkFlowStatus('flow', '/fake/projectDir/'), 'Invalid Flow status JSON format');

          case 9:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));

  return function (_x3) {
    return _ref3.apply(this, arguments);
  };
}());

(0, _ava.test)('collectFlowCoverageForFile collects flow command exit errors', function () {
  var _ref4 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4(t) {
    var exec, tempPath, writeFile, fakeExecError, flow, filename, collectData;
    return _regenerator2.default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            exec = _sinon2.default.stub();
            tempPath = _sinon2.default.stub();
            writeFile = _sinon2.default.stub();


            (0, _mockRequire2.default)(NPM_TEMP, { path: tempPath });
            (0, _mockRequire2.default)(LIB_PROMISIFIED, { exec: exec, writeFile: writeFile });

            fakeExecError = {
              err: {
                message: 'Fake flow error without stdout',
                code: 2
              }
            };


            exec.onFirstCall().returns(Promise.resolve(fakeExecError));

            flow = _mockRequire2.default.reRequire(LIB_FLOW);
            filename = 'src/fakeFilename.js';
            _context4.next = 11;
            return flow.collectFlowCoverageForFile('flow', '/fake/projectDir/', filename, tmpDirPath);

          case 11:
            collectData = _context4.sent;


            // Expect a flow coverage exception in the collected data.
            t.true(collectData.isError);
            t.is(collectData.flowCoverageException, fakeExecError.err.message);

            // Expect empty flow coverage data when a coverage exception has been collected.
            t.deepEqual(collectData.expressions, {
              /* eslint-disable camelcase */
              covered_count: 0,
              uncovered_count: 0,
              uncovered_locs: []
              /* eslint-enable camelcase */
            });

            t.true(exec.calledOnce);
            t.is(writeFile.callCount, 0);

          case 17:
          case 'end':
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));

  return function (_x4) {
    return _ref4.apply(this, arguments);
  };
}());

(0, _ava.test)('collectFlowCoverageForFile collects parsing errors', function () {
  var _ref5 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5(t) {
    var exec, tempPath, writeFile, flow, filename, collectData, expectedParsingError;
    return _regenerator2.default.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            exec = _sinon2.default.stub();
            tempPath = _sinon2.default.stub();
            writeFile = _sinon2.default.stub();


            (0, _mockRequire2.default)(NPM_TEMP, { path: tempPath });
            (0, _mockRequire2.default)(LIB_PROMISIFIED, { exec: exec, writeFile: writeFile });

            exec.onFirstCall().returns(Promise.resolve({
              stdout: '{'
            }));

            flow = _mockRequire2.default.reRequire(LIB_FLOW);
            filename = 'src/fakeFilename.js';
            _context5.next = 10;
            return flow.collectFlowCoverageForFile('flow', '/fake/projectDir/', filename, tmpDirPath);

          case 10:
            collectData = _context5.sent;
            expectedParsingError = void 0;

            try {
              JSON.parse('{');
            } catch (err) {
              expectedParsingError = err;
            }

            // Expect a flow coverage exception in the collected data.
            t.true(collectData.isError);
            t.is(collectData.flowCoverageParsingError, expectedParsingError.message);

            // Expect empty flow coverage data when a coverage exception has been collected.
            t.deepEqual(collectData.expressions, {
              /* eslint-disable camelcase */
              covered_count: 0,
              uncovered_count: 0,
              uncovered_locs: []
              /* eslint-enable camelcase */
            });

            t.true(exec.calledOnce);
            t.is(writeFile.callCount, 0);

          case 18:
          case 'end':
            return _context5.stop();
        }
      }
    }, _callee5, this);
  }));

  return function (_x5) {
    return _ref5.apply(this, arguments);
  };
}());

(0, _ava.test)('collectFlowCoverageForFile collects coverage errors', function () {
  var _ref6 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6(t) {
    var exec, tempPath, writeFile, flow, filename, collectData;
    return _regenerator2.default.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            exec = _sinon2.default.stub();
            tempPath = _sinon2.default.stub();
            writeFile = _sinon2.default.stub();


            (0, _mockRequire2.default)(NPM_TEMP, { path: tempPath });
            (0, _mockRequire2.default)(LIB_PROMISIFIED, { exec: exec, writeFile: writeFile });

            exec.onFirstCall().returns(Promise.resolve({
              stderr: '{"error": "Fake flow coverage message"}'
            }));

            flow = _mockRequire2.default.reRequire(LIB_FLOW);
            filename = 'src/fakeFilename.js';
            _context6.next = 10;
            return flow.collectFlowCoverageForFile('flow', '/fake/projectDir/', filename, tmpDirPath);

          case 10:
            collectData = _context6.sent;


            // Expect a flow coverage exception in the collected data.
            t.true(collectData.isError);
            t.is(collectData.flowCoverageError, 'Fake flow coverage message');

            // Expect empty flow coverage data when a coverage exception has been collected.
            t.deepEqual(collectData.expressions, {
              /* eslint-disable camelcase */
              covered_count: 0,
              uncovered_count: 0,
              uncovered_locs: []
              /* eslint-enable camelcase */
            });

            t.true(exec.calledOnce);
            t.is(writeFile.callCount, 0);

          case 16:
          case 'end':
            return _context6.stop();
        }
      }
    }, _callee6, this);
  }));

  return function (_x6) {
    return _ref6.apply(this, arguments);
  };
}());

(0, _ava.test)('collectFlowCoverageForFile resolve coverage data', function () {
  var _ref7 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee7(t) {
    var exec, writeFile, tempPath, filename, fakeFlowCoverageData, flow, res;
    return _regenerator2.default.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            exec = _sinon2.default.stub();
            writeFile = _sinon2.default.stub();
            tempPath = _sinon2.default.stub();


            (0, _mockRequire2.default)(NPM_TEMP, { path: tempPath });
            (0, _mockRequire2.default)(LIB_PROMISIFIED, { exec: exec, writeFile: writeFile });

            filename = 'src/fakeFilename.js';
            fakeFlowCoverageData = {
              filename: filename,
              fakeCoverageData: {
                ok: true
              }
            };


            tempPath.onFirstCall().returns(tmpFilePath);
            exec.onFirstCall().returns(Promise.resolve({
              stdout: new Buffer(JSON.stringify(fakeFlowCoverageData))
            }));

            flow = _mockRequire2.default.reRequire(LIB_FLOW);
            _context7.next = 12;
            return flow.collectFlowCoverageForFile('flow', _index.DEFAULT_FLOW_TIMEOUT, '/fake/projectDir', filename);

          case 12:
            res = _context7.sent;


            t.is(writeFile.callCount, 0);
            t.true(exec.calledOnce);
            t.is(exec.firstCall.args[0], 'flow coverage --json ' + filename);
            t.deepEqual(exec.firstCall.args[1], {
              cwd: '/fake/projectDir', maxBuffer: Infinity, timeout: _index.DEFAULT_FLOW_TIMEOUT
            });
            t.deepEqual(res, fakeFlowCoverageData);

          case 18:
          case 'end':
            return _context7.stop();
        }
      }
    }, _callee7, this);
  }));

  return function (_x7) {
    return _ref7.apply(this, arguments);
  };
}());

(0, _ava.test)('collectFlowCoverage', function () {
  var _ref8 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee8(t) {
    var exec, writeFile, tempPath, glob, fakeFlowStatus, firstGlobResults, secondGlobResults, allFiles, i, flow, globIncludePatterns, globExcludePatterns, res, resFiles, filteredFiles, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, filename;

    return _regenerator2.default.wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            exec = _sinon2.default.stub();
            writeFile = _sinon2.default.stub();
            tempPath = _sinon2.default.stub();
            glob = _sinon2.default.stub();


            (0, _mockRequire2.default)(NPM_TEMP, { path: tempPath });
            (0, _mockRequire2.default)(LIB_PROMISIFIED, { exec: exec, glob: glob, writeFile: writeFile });

            fakeFlowStatus = {
              passed: true,
              errors: [],
              flowVersion: '0.30.0'
            };
            firstGlobResults = ['src/a.js', 'src/b.js', 'test/test-a.js'];
            secondGlobResults = ['src/d1/c.js', 'src/d1/d.js', 'test/subdir/test-d.js'];

            // Fake reply to flow status command.

            exec.onCall(0).returns(Promise.resolve({
              stdout: JSON.stringify(fakeFlowStatus)
            }));

            // Fake the glob results.
            glob.onCall(0).returns(Promise.resolve(firstGlobResults));
            glob.onCall(1).returns(Promise.resolve(secondGlobResults));

            allFiles = [].concat(firstGlobResults, secondGlobResults);

            // Fake the flow coverage commands results.

            for (i = 1; i <= allFiles.length; i++) {
              exec.onCall(i).returns(Promise.resolve({
                stdout: JSON.stringify({
                  /* eslint-disable camelcase */
                  expressions: {
                    covered_count: 1,
                    uncovered_count: 1,
                    uncovered_locs: [{
                      start: {
                        source: allFiles[i],
                        line: 1,
                        column: 1,
                        offset: 10
                      },
                      end: {
                        source: allFiles[i],
                        line: 2,
                        column: 2,
                        offset: 30
                      }
                    }]
                  }
                  /* eslint-enable camelcase */
                })
              }));
            }

            flow = _mockRequire2.default.reRequire(LIB_FLOW);
            globIncludePatterns = ['src/*.js', 'src/*/*.js'];
            globExcludePatterns = ['test/**'];
            _context8.next = 19;
            return flow.collectFlowCoverage('flow', _index.DEFAULT_FLOW_TIMEOUT, '/projectDir', globIncludePatterns, globExcludePatterns, 80, 5);

          case 19:
            res = _context8.sent;


            t.is((0, _typeof3.default)(res.generatedAt), 'string');
            delete res.generatedAt;

            resFiles = res.files;

            delete res.files;

            t.deepEqual(res, {
              flowStatus: (0, _extends3.default)({}, fakeFlowStatus),
              globIncludePatterns: globIncludePatterns,
              globExcludePatterns: globExcludePatterns,
              concurrentFiles: 5,
              percent: 50,
              threshold: 80,
              /* eslint-disable camelcase */
              covered_count: 4,
              uncovered_count: 4
              /* eslint-enable camelcase */
            });

            filteredFiles = allFiles.filter(function (file) {
              return !(0, _minimatch2.default)(file, globExcludePatterns[0]);
            }).sort();


            t.deepEqual(Object.keys(resFiles).sort(), filteredFiles);

            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _iteratorError = undefined;
            _context8.prev = 30;
            for (_iterator = filteredFiles[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              filename = _step.value;

              t.deepEqual(resFiles[filename].expressions.uncovered_locs, [{
                start: {
                  line: 1,
                  column: 1,
                  offset: 10
                },
                end: {
                  line: 2,
                  column: 2,
                  offset: 30
                }
              }]);
              delete resFiles[filename].expressions.uncovered_locs;
              t.deepEqual(resFiles[filename], {
                percent: 50,
                filename: filename,
                expressions: {
                  /* eslint-disable camelcase */
                  covered_count: 1,
                  uncovered_count: 1
                  /* eslint-enable camelcase */
                }
              });
            }

            _context8.next = 38;
            break;

          case 34:
            _context8.prev = 34;
            _context8.t0 = _context8['catch'](30);
            _didIteratorError = true;
            _iteratorError = _context8.t0;

          case 38:
            _context8.prev = 38;
            _context8.prev = 39;

            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }

          case 41:
            _context8.prev = 41;

            if (!_didIteratorError) {
              _context8.next = 44;
              break;
            }

            throw _iteratorError;

          case 44:
            return _context8.finish(41);

          case 45:
            return _context8.finish(38);

          case 46:
            t.is(writeFile.callCount, 0);
            t.is(exec.callCount, 5);
            t.is(glob.callCount, 2);

          case 49:
          case 'end':
            return _context8.stop();
        }
      }
    }, _callee8, this, [[30, 34, 38, 46], [39,, 41, 45]]);
  }));

  return function (_x8) {
    return _ref8.apply(this, arguments);
  };
}());

(0, _ava.test)('getCoveredPercent', function (t) {
  var flow = _mockRequire2.default.reRequire(LIB_FLOW);

  /* eslint-disable camelcase */
  t.is(flow.getCoveredPercent({ covered_count: 0, uncovered_count: 0 }), 100);
  t.is(flow.getCoveredPercent({ covered_count: 0, uncovered_count: 10 }), 0);
  t.is(flow.getCoveredPercent({ covered_count: 3, uncovered_count: 11 }), 21);
  /* eslint-enable camelcase */
});
//# sourceMappingURL=test-flow.js.map