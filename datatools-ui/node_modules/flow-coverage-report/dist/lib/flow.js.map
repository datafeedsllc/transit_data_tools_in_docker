{"version":3,"sources":["../../src/lib/flow.js"],"names":["flowCommandPath","projectDir","tmpDirPath","tmpFilePath","process","env","VERBOSE","path","suffix","dir","cwd","maxBuffer","Infinity","dontReject","res","err","code","console","error","stderr","stdout","statusData","log","JSON","parse","String","unexpectedException","Error","flowVersion","checkFlowStatus","flowCommandTimeout","filename","emptyCoverageData","expressions","covered_count","uncovered_count","uncovered_locs","timeout","isError","flowCoverageError","undefined","flowCoverageException","message","flowCoverageStderr","flowCoverageParsingError","parsedData","collectFlowCoverageForFile","Array","prototype","find","require","shim","getCoveredPercent","total","Math","floor","exports","collectFlowCoverage","globIncludePatterns","globExcludePatterns","threshold","concurrentFiles","then","waitForCollectedDataFromFiles","length","Promise","all","drainQueue","now","Date","coverageGeneratedAt","toDateString","toTimeString","coverageSummaryData","percent","generatedAt","flowStatus","files","cleanupUncoveredLoc","loc","start","source","end","collectCoverageAndGenerateReportForGlob","globIncludePattern","root","pattern","push","data","map"],"mappings":"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","file":"flow.js","sourcesContent":["'use strict';\n\n// @flow\n\nimport minimatch from 'minimatch';\nimport temp from 'temp';\nimport {exec, glob, writeFile} from './promisified';\n\n// Load the Array.prototype.find polyfill if needed (e.g. nodejs 0.12).\nif (!Array.prototype.find) {\n  require('array.prototype.find').shim();\n}\n\n// getCoveredPercent helper.\n\n/* eslint-disable camelcase */\nfunction getCoveredPercent(\n  {\n    covered_count, uncovered_count\n  }: {\n    covered_count: number, uncovered_count: number\n  }\n) {\n  const total = covered_count + uncovered_count;\n\n  if (total === 0) {\n    return 100;\n  }\n\n  return Math.floor(covered_count / total * 100);\n}\n/* eslint-disable-line camelcase */\nexports.getCoveredPercent = getCoveredPercent;\n\n// checkFlowStatus definitions and its related flow types.\n\nexport type FlowTypeErrorPosition = {\n  offset: number,\n  column: number,\n  line: number\n}\n\nexport type FlowTypeErrorMessage = {\n  type: string,\n  start: number,\n  end: number,\n  line: number,\n  endline: number,\n  path: string,\n  descr: string,\n  context?: string,\n  loc?: {\n    start: FlowTypeErrorPosition,\n    end: FlowTypeErrorPosition,\n    type: string,\n    source: string\n  }\n}\n\nexport type FlowTypeError = {\n  kind: string,\n  level: string,\n  message: Array<FlowTypeErrorMessage>\n}\n\nexport type FlowStatus = {\n  passed: boolean,\n  flowVersion: string,\n  errors: Array<FlowTypeError>\n}\n\nasync function checkFlowStatus(\n  flowCommandPath: string,\n  projectDir: string,\n  tmpDirPath: ?string\n): Promise<FlowStatus> {\n  let tmpFilePath: ?string;\n\n  if (process.env.VERBOSE && process.env.VERBOSE === 'DUMP_JSON') {\n    tmpFilePath = temp.path({suffix: '.json', dir: tmpDirPath});\n  }\n\n  const res = await exec(`${flowCommandPath} status --json`,\n                         {cwd: projectDir, maxBuffer: Infinity},\n                         {dontReject: true});\n\n  // $FLOW_FIXME: code is there, but flow doesn't seem to know about it.\n  if (res.err && res.err.code !== 2) {\n    if (process.env.VERBOSE) {\n      console.error('Flow status error', res.err, res.stderr, res.stdout);\n    }\n\n    throw res.err;\n  }\n\n  let statusData: ?FlowStatus;\n\n  if (tmpFilePath) {\n    await writeFile(tmpFilePath, res.stdout || '');\n    console.log('Flow status result saved to', tmpFilePath);\n  }\n\n  try {\n    statusData = JSON.parse(String(res.stdout));\n  } catch (err) {\n    let unexpectedException: ?SyntaxError = err;\n\n    // Verify the integrity of the format of the JSON status result.\n    if (unexpectedException) {\n      throw new Error(`Parsing error on Flow status JSON result: ${err}`);\n    }\n  }\n\n  if (statusData && statusData.flowVersion) {\n    return statusData;\n  }\n\n  throw new Error('Invalid Flow status JSON format');\n}\n\nexports.checkFlowStatus = checkFlowStatus;\n\n// collectFlowCoverageForFile definitions and its related flow types.\n\nexport type FlowUncoveredPos = {\n  line: number,\n  column: number,\n  offset: number,\n  source: string\n}\n\nexport type FlowUncoveredLoc = {\n  start: FlowUncoveredPos,\n  end: FlowUncoveredPos\n}\n\nexport type FlowCoverageJSONData = {\n  expressions: {\n    covered_count: number,\n    uncovered_count: number,\n    uncovered_locs: Array<FlowUncoveredLoc>\n  },\n  filename?: string,\n  percent?: number,\n  error?: string,\n  isError?: boolean,\n  flowCoverageError?: ?string,\n  flowCoverageException?: ?string,\n  flowCoverageParsingError?: ?string,\n  flowCoverageStderr?: string|Buffer\n}\n\nasync function collectFlowCoverageForFile(\n  flowCommandPath: string,\n  flowCommandTimeout: number,\n  projectDir: string,\n  filename: string,\n  tmpDirPath: ?string,\n): Promise<FlowCoverageJSONData> {\n  let tmpFilePath: ?string;\n\n  if (process.env.VERBOSE && process.env.VERBOSE === 'DUMP_JSON') {\n    tmpFilePath = temp.path({suffix: '.json', dir: tmpDirPath});\n  }\n\n  const emptyCoverageData = {\n    filename,\n    expressions: {\n      covered_count: 0,\n      uncovered_count: 0,\n      uncovered_locs: []\n    }\n  };\n\n  if (process.env.VERBOSE) {\n    console.log(`Collecting coverage data from ${filename} (timeouts in ${flowCommandTimeout})...`);\n  }\n\n  const res = await exec(\n    `${flowCommandPath} coverage --json ${filename}`,\n    // NOTE: set a default timeouts and maxButter to Infinity to prevent,\n    // misconfigured projects and source files that should raises errors\n    // or hangs the flow daemon to prevent the coverage reporter to complete\n    // the data collection. (See https://github.com/rpl/flow-coverage-report/pull/4\n    // and https://github.com/rpl/flow-coverage-report/pull/5 for rationale,\n    // thanks to to @mynameiswhm and @ryan953  for their help on hunting down this issue)\n    {cwd: projectDir, timeout: flowCommandTimeout, maxBuffer: Infinity},\n    {dontReject: true});\n\n  if (res.err) {\n    console.error(`ERROR Collecting coverage data from ${filename} `, filename, res.err, res.stderr);\n\n    if (process.env.VERBOSE) {\n      if (tmpFilePath) {\n        await writeFile(tmpFilePath, res.stdout || '');\n      }\n    }\n\n    // TODO: collect errors and put them in a visible place in the\n    // generated report.\n    return {\n      ...emptyCoverageData,\n      isError: true,\n      flowCoverageError: undefined,\n      flowCoverageException: res.err && res.err.message,\n      flowCoverageStderr: res.stderr,\n      flowCoverageParsingError: undefined\n    };\n  }\n\n  if (process.env.VERBOSE) {\n    console.log(`Collecting coverage data from ${filename} completed.`);\n    if (tmpFilePath) {\n      await writeFile(tmpFilePath, res.stdout || '');\n      console.log(`Saved json dump of collected coverage data from ${filename} to ${tmpFilePath}.`);\n    }\n  }\n\n  let parsedData: ?FlowCoverageJSONData;\n  let flowCoverageParsingError: string;\n\n  if (res.stdout) {\n    try {\n      parsedData = JSON.parse(String(res.stdout));\n    } catch (err) {\n      flowCoverageParsingError = err.message;\n    }\n  }\n\n  if (res.stderr) {\n    try {\n      parsedData = JSON.parse(String(res.stderr));\n      delete res.stderr;\n    } catch (err) {\n    }\n  }\n\n  if (parsedData && !parsedData.error) {\n    parsedData.filename = filename;\n    return parsedData;\n  }\n\n  return {\n    ...emptyCoverageData,\n    isError: true,\n    flowCoverageError: parsedData && parsedData.error,\n    flowCoverageException: undefined,\n    flowCoverageParsingError,\n    flowCoverageStderr: res.stderr\n  };\n}\n\nexports.collectFlowCoverageForFile = collectFlowCoverageForFile;\n\n// collectForCoverage definitions and its related flow types.\n\nexport type FlowCoverageSummaryData = {\n  covered_count: number,\n  uncovered_count: number,\n  percent: number,\n  threshold: number,\n  generatedAt: string,\n  flowStatus: FlowStatus,\n  globIncludePatterns: Array<string>,\n  globExcludePatterns: Array<string>,\n  concurrentFiles: number,\n  files: {\n    [key: string]: FlowCoverageJSONData\n  }\n}\n\nexports.collectFlowCoverage = function (\n  flowCommandPath: string,\n  flowCommandTimeout: number,\n  projectDir: string,\n  globIncludePatterns: Array<string>,\n  globExcludePatterns: Array<string>,\n  threshold: number,\n  concurrentFiles: number,\n  tmpDirPath: ?string,\n): Promise<FlowCoverageSummaryData> {\n  return checkFlowStatus(flowCommandPath, projectDir, tmpDirPath).then(flowStatus => {\n    var now = new Date();\n    var coverageGeneratedAt = now.toDateString() + ' ' + now.toTimeString();\n\n    var coverageSummaryData: FlowCoverageSummaryData = {\n      threshold,\n      covered_count: 0, uncovered_count: 0, // eslint-disable-line camelcase\n      percent: 0,\n      generatedAt: coverageGeneratedAt,\n      flowStatus: flowStatus,\n      files: {},\n      globIncludePatterns: globIncludePatterns,\n      globExcludePatterns: globExcludePatterns,\n      concurrentFiles: concurrentFiles\n    };\n\n    // Remove the source attribute from all ucovered_locs entry.\n    function cleanupUncoveredLoc(loc) {\n      delete loc.start.source;\n      delete loc.end.source;\n      return loc;\n    }\n\n    let waitForCollectedDataFromFiles = [];\n\n    async function drainQueue() {\n      if (process.env.VERBOSE) {\n        console.log(`Wait for ${waitForCollectedDataFromFiles.length} queued files.`);\n      }\n      // Wait the queued files.\n      await Promise.all(waitForCollectedDataFromFiles);\n      // Empty the collected Data From files queue.\n      waitForCollectedDataFromFiles = [];\n    }\n\n    function collectCoverageAndGenerateReportForGlob(globIncludePattern) {\n      return glob(globIncludePattern, {cwd: projectDir, root: projectDir})\n        .then(async files => {\n          for (const filename of files) {\n            // Skip files that match any of the exclude patterns.\n            if (globExcludePatterns.find(pattern => minimatch(filename, pattern)) !== undefined) {\n              if (process.env.VERBOSE) {\n                console.log(`Skip ${filename}, matched excluded pattern.`);\n              }\n              continue;\n            }\n\n            if (process.env.VERBOSE) {\n              console.log(`Queue ${filename} flow coverage data collection`);\n            }\n\n            waitForCollectedDataFromFiles.push(collectFlowCoverageForFile(\n              flowCommandPath, flowCommandTimeout, projectDir, filename, tmpDirPath\n            ).then(data => {\n              /* eslint-disable camelcase */\n              coverageSummaryData.covered_count += data.expressions.covered_count;\n              coverageSummaryData.uncovered_count += data.expressions.uncovered_count;\n              data.percent = getCoveredPercent(data.expressions);\n\n              if (!data.filename) {\n                throw new Error('Unxepected missing filename from collected coverage data');\n              }\n\n              coverageSummaryData.files[data.filename] = data;\n\n              data.expressions.uncovered_locs =\n                data.expressions.uncovered_locs.map(cleanupUncoveredLoc);\n              /* eslint-enable camelcase */\n            }));\n\n            // If we have collected at least `concurrentFiles` number of files,\n            // wait the queue to be drained.\n            if (waitForCollectedDataFromFiles.length >= concurrentFiles) {\n              await drainQueue();\n            }\n          }\n\n          // Wait for any remaining queued file.\n          if (waitForCollectedDataFromFiles.length > 0) {\n            await drainQueue();\n          }\n\n          return files;\n        });\n    }\n\n    return Promise\n      .all(globIncludePatterns.map(collectCoverageAndGenerateReportForGlob))\n      .then(() => {\n        coverageSummaryData.percent = getCoveredPercent(coverageSummaryData);\n\n        return coverageSummaryData;\n      });\n  });\n};\n"]}