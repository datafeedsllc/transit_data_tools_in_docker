"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.middleware = exports.abortAllFetches = exports.abortFetch = exports.default = exports.fetchMultiple = exports.fetchAction = exports.FETCH_ERROR = exports.FETCH_MULTIPLE = exports.FETCH = exports.DECREMENT_FETCH = exports.INCREMENT_FETCH = exports.ABORT_FETCH_FAILED = exports.ABORTED_FETCH = exports.isActive = exports.getID = void 0;

require("core-js/modules/es7.object.get-own-property-descriptors");

require("core-js/modules/es6.array.from");

require("core-js/modules/es6.regexp.to-string");

require("core-js/modules/es7.symbol.async-iterator");

require("core-js/modules/es6.symbol");

require("core-js/modules/es6.promise");

require("core-js/modules/es6.string.iterator");

require("regenerator-runtime/runtime");

require("core-js/modules/web.dom.iterable");

require("core-js/modules/es6.array.iterator");

require("core-js/modules/es6.object.to-string");

require("core-js/modules/es6.object.keys");

require("core-js/modules/es7.array.includes");

require("core-js/modules/es6.string.includes");

var _get = _interopRequireDefault(require("lodash/get"));

var _isObject = _interopRequireDefault(require("lodash/isObject"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

if (typeof fetch === 'undefined') {
  require('isomorphic-fetch');
} // Generic fetch type


var GFT = '__FETCH__'; // ID that gets incremented for each fetch

var FETCH_ID = 0; // Get's the next fetch ID, which can be passed in to `fetch`, and allows for
// tracking the fetch or aborting it.

var getID = function getID() {
  return ++FETCH_ID;
}; // Active fetches, can still be aborted


exports.getID = getID;

var activeFetches = _defineProperty({}, GFT, []); // Remove a fetch from the active pool


var removeFetch = function removeFetch(sig) {
  if (sig.type === GFT) {
    activeFetches[GFT].splice(activeFetches[GFT].indexOf(sig.id), 1);
  } else {
    delete activeFetches[sig.type];
  }
}; // Check if a fetch is still active


var isActive = function isActive(sig) {
  if (sig.type === GFT) return activeFetches[GFT].includes(sig.id);
  if (activeFetches[sig.type] === undefined) return false;
  if (sig.id === undefined) return true;
  return activeFetches[sig.type] === sig.id;
}; // Action types


exports.isActive = isActive;
var ABORTED_FETCH = 'aborted fetch';
exports.ABORTED_FETCH = ABORTED_FETCH;
var ABORT_FETCH_FAILED = 'abort fetch failed';
exports.ABORT_FETCH_FAILED = ABORT_FETCH_FAILED;
var INCREMENT_FETCH = 'increment outstanding fetches';
exports.INCREMENT_FETCH = INCREMENT_FETCH;
var DECREMENT_FETCH = 'decrement outstanding fetches';
exports.DECREMENT_FETCH = DECREMENT_FETCH;
var FETCH = 'fetch';
exports.FETCH = FETCH;
var FETCH_MULTIPLE = 'fetch multiple';
exports.FETCH_MULTIPLE = FETCH_MULTIPLE;
var FETCH_ERROR = 'fetch error'; // Simple action creator

exports.FETCH_ERROR = FETCH_ERROR;

var createAction = function createAction(type) {
  return function (payload) {
    return {
      type: type,
      payload: payload
    };
  };
}; // Main actions to be dispatched


var fetchAction = createAction(FETCH);
exports.fetchAction = fetchAction;
var fetchMultiple = createAction(FETCH_MULTIPLE);
exports.fetchMultiple = fetchMultiple;
var _default = fetchAction; // Internally dispatched actions

exports.default = _default;
var abortedFetch = createAction(ABORTED_FETCH);
var abortFetchFailed = createAction(ABORT_FETCH_FAILED);
var fetchError = createAction(FETCH_ERROR);
/**
 * Call decrement and dispatch "aborted" and "decrement" actions. If `id` is
 * not set, cancel all fetches for the given type.
 */

var abortFetch = function abortFetch(sig) {
  if (isActive(sig)) {
    return [abortedFetch(sig), decrementFetches(sig)];
  } else {
    return abortFetchFailed(sig);
  }
}; // Abort all active fetches


exports.abortFetch = abortFetch;

var abortAllFetches = function abortAllFetches() {
  return Object.keys(activeFetches).reduce(function (aborts, fetchType) {
    if (fetchType === GFT) {
      return [].concat(_toConsumableArray(aborts), _toConsumableArray(activeFetches[GFT].map(function (id) {
        return abortFetch({
          type: GFT,
          id: id
        });
      })));
    } else {
      return [].concat(_toConsumableArray(aborts), [abortFetch({
        type: fetchType,
        id: activeFetches[fetchType]
      })]);
    }
  }, []);
};
/**
 * Send an increment action and add the fetch to the active list. This will also
 * abort a previous fetch of the same type if it exists.
 */


exports.abortAllFetches = abortAllFetches;

var incrementFetches = function incrementFetches(payload) {
  var actions = [{
    type: INCREMENT_FETCH,
    payload: payload
  }];
  if (payload.type === GFT) activeFetches[GFT].push(payload.id);else {
    if (activeFetches[payload.type] !== undefined) {
      actions.push(abortFetch({
        type: payload.type,
        id: activeFetches[payload.type]
      }));
    }

    activeFetches[payload.type] = payload.id;
  }
  return actions;
};
/**
 * Send a decrement action and remove the fetch from the active list.
 */


var decrementFetches = function decrementFetches(signature) {
  removeFetch(signature);
  return {
    type: DECREMENT_FETCH,
    payload: signature
  };
}; // Redux middleware


var middleware = function middleware(store) {
  return function (next) {
    return function (action) {
      switch ((0, _get.default)(action, 'type')) {
        case FETCH:
          return store.dispatch(runFetchAction(action.payload, store.getState()));

        case FETCH_MULTIPLE:
          return store.dispatch(runFetchMultiple(action.payload, store.getState()));

        default:
          return next(action);
      }
    };
  };
};
/**
 * Calls fetch, adds Auth and Content header if needed. Automatically parses
 * content based on type.
 *
 * @returns Promise
 */


exports.middleware = middleware;

function runFetch(_ref, state) {
  var signature = _ref.signature,
      _ref$options = _ref.options,
      options = _ref$options === void 0 ? {} : _ref$options,
      _ref$retry = _ref.retry,
      retry = _ref$retry === void 0 ? false : _ref$retry,
      url = _ref.url;

  var headers = _objectSpread({}, createAuthorizationHeader(state), {}, createContentHeader(options.body), {}, options.headers || {});

  var filteredHeaders = {}; // Allow removing generated headers by specifiying { header: null } in
  // options.headers. Do this in two steps because otherwise we're modifying
  // the object as we're iterating over it.

  Object.keys(headers).filter(function (key) {
    return headers[key] !== null && headers[key] !== undefined;
  }).forEach(function (key) {
    filteredHeaders[key] = headers[key];
  });
  return fetch(url, _objectSpread({}, options, {
    body: serialize(options.body),
    headers: filteredHeaders
  })).then(checkStatus).then(createResponse).then(
  /*#__PURE__*/
  function () {
    var _ref2 = _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee(response) {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.t0 = retry && isActive(signature);

              if (!_context.t0) {
                _context.next = 5;
                break;
              }

              _context.next = 4;
              return retry(response);

            case 4:
              _context.t0 = _context.sent;

            case 5:
              if (!_context.t0) {
                _context.next = 9;
                break;
              }

              _context.t1 = runFetch({
                signature: signature,
                options: options,
                retry: retry,
                url: url
              }, state);
              _context.next = 10;
              break;

            case 9:
              _context.t1 = response;

            case 10:
              return _context.abrupt("return", _context.t1);

            case 11:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x) {
      return _ref2.apply(this, arguments);
    };
  }());
}
/**
 * Part of Redux action cycle. Returns an array of actions.
 */


function runFetchAction(_ref3, state) {
  var _ref3$type = _ref3.type,
      type = _ref3$type === void 0 ? GFT : _ref3$type,
      _ref3$id = _ref3.id,
      id = _ref3$id === void 0 ? getID() : _ref3$id,
      next = _ref3.next,
      _ref3$options = _ref3.options,
      options = _ref3$options === void 0 ? {} : _ref3$options,
      _ref3$retry = _ref3.retry,
      retry = _ref3$retry === void 0 ? false : _ref3$retry,
      url = _ref3.url;
  // Fetch signature based on the `type` and `id`
  var signature = {
    type: type,
    id: id // If next does not exist or only takes a response, dispatch on error

  };
  var dispatchFetchError = !next || next.length < 2; // Wrap next so that we can parse the response

  var wrappedNext = wrapNext(next);
  return [incrementFetches({
    type: type,
    id: id,
    options: options,
    url: url
  }), runFetch({
    signature: signature,
    options: options,
    retry: retry,
    url: url
  }, state).then(function (response) {
    if (isActive(signature)) {
      return [decrementFetches(signature), wrappedNext(null, response)];
    }
  }).catch(function (error) {
    return createErrorResponse(error).then(function (response) {
      if (isActive(signature)) {
        var actions = [decrementFetches(signature), wrappedNext(error, response)];
        if (dispatchFetchError) actions.push(fetchError(response));
        return actions;
      }
    });
  })];
}
/**
 * @returns Array of actions
 */


function runFetchMultiple(_ref4, state) {
  var _ref4$type = _ref4.type,
      type = _ref4$type === void 0 ? GFT : _ref4$type,
      _ref4$id = _ref4.id,
      id = _ref4$id === void 0 ? getID() : _ref4$id,
      fetches = _ref4.fetches,
      next = _ref4.next;
  var signature = {
    type: type,
    id: id
  };
  var dispatchFetchError = !next || next.length < 2;
  var wrappedNext = wrapNext(next);
  return [incrementFetches({
    type: type,
    id: id,
    fetches: fetches
  }), Promise.all(fetches.map(function (fetch) {
    return runFetch(_objectSpread({}, fetch, {
      signature: signature
    }), state);
  })).then(function (responses) {
    if (isActive(signature)) {
      return [decrementFetches(signature), wrappedNext(null, responses)];
    }
  }).catch(function (error) {
    return createErrorResponse(error).then(function (response) {
      if (isActive(signature)) {
        var actions = [decrementFetches(signature), wrappedNext(error, response)];
        if (dispatchFetchError) actions.push(fetchError(response));
        return actions;
      }
    });
  })];
}
/**
 * TODO: Expose this function to allow for customization.
 */


function createAuthorizationHeader(state) {
  return state.user && state.user.idToken ? {
    Authorization: "bearer ".concat(state.user.idToken)
  } : {};
}

function checkStatus(res) {
  if (res.status >= 200 && res.status < 300) {
    return res;
  } else {
    throw res;
  }
}

function createContentHeader(body) {
  if (body instanceof window.FormData) {
    return {};
  } else if ((0, _isObject.default)(body)) {
    return {
      'Accept': 'application/json',
      'Content-Type': 'application/json;charset=UTF-8'
    };
  } else {
    return {};
  }
}

function createErrorResponse(res) {
  return res.headers ? createResponse(res) : Promise.resolve(res);
}

function createResponse(res) {
  return deserialize(res).then(function (value) {
    res.value = value;
    return res;
  }).catch(function (err) {
    res.value = err;
    return res;
  });
}

function deserialize(_x2) {
  return _deserialize.apply(this, arguments);
}

function _deserialize() {
  _deserialize = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee2(res) {
    var header;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            header = "".concat(res.headers.get('Content-Type'), " ").concat(res.headers.get('Content'));

            if (!(header.indexOf('json') > -1)) {
              _context2.next = 3;
              break;
            }

            return _context2.abrupt("return", res.json());

          case 3:
            if (!(header.indexOf('octet-stream') > -1)) {
              _context2.next = 5;
              break;
            }

            return _context2.abrupt("return", res.arrayBuffer());

          case 5:
            if (!(header.indexOf('text') > -1)) {
              _context2.next = 7;
              break;
            }

            return _context2.abrupt("return", res.text());

          case 7:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _deserialize.apply(this, arguments);
}

function serialize(body) {
  if (body instanceof window.FormData) {
    return body;
  } else if ((0, _isObject.default)(body)) {
    return JSON.stringify(body);
  } else {
    return body;
  }
}

function wrapNext(next) {
  return function (error, response) {
    if (next) {
      if (next.length > 1) {
        return next(error, response);
      } else if (!error) {
        return next(response);
      }
    }
  };
}

//# sourceMappingURL=fetch.js